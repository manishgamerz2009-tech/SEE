<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Mini Battle: 1-4 Player Offline Games üéÆ</title>
    <link href="https://fonts.googleapis.com/css2?family=Fredoka+One&display=swap" rel="stylesheet">

    <style>
        /* CSS START */
        body, html {
            margin: 0; padding: 0; font-family: 'Fredoka One', cursive; 
            background-color: #f7f7f7; color: #333; overflow: hidden; 
            user-select: none; touch-action: manipulation; 
            padding-bottom: 50px; /* Space for the bottom banner */
        }
        #game-container {
            display: flex; justify-content: center; align-items: center;
            width: 100vw; height: 100vh; box-sizing: border-box; position: relative; 
        }
        
        /* ADMOB STYLES */
        #banner-ad-container {
            position: fixed; bottom: 0; left: 0; width: 100%; height: 50px;
            background-color: #333; color: #fff; text-align: center; line-height: 50px;
            font-size: 0.9em; box-shadow: 0 -2px 10px rgba(0, 0, 0, 0.2);
            z-index: 1000; display: none; 
        }
        #ad-overlay {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background-color: rgba(0, 0, 0, 0.9); color: white; z-index: 2000;
            display: none; flex-direction: column; justify-content: center; align-items: center;
        }
        #ad-close-btn {
            position: absolute; top: 20px; right: 20px; background: #ff6347; color: white;
            border: 2px solid white; border-radius: 50%; width: 40px; height: 40px;
            font-size: 1.5em; cursor: pointer; box-shadow: 0 4px #cc4e37;
            line-height: 35px; text-align: center;
        }

        /* SCREEN & BUTTON STYLES */
        .screen {
            position: absolute; width: 90%; max-width: 600px; padding: 20px;
            background-color: #fff; border-radius: 20px; box-shadow: 0 10px 30px rgba(0, 0, 0, 0.2);
            text-align: center; display: none; box-sizing: border-box; margin-bottom: 50px; 
        }
        .screen.active { display: block; }
        h1 { color: #ff6347; font-size: 3em; margin-bottom: 5px;}
        button {
            padding: 15px 30px; margin: 10px 0; border: none; border-radius: 10px;
            background-color: #4682b4; color: white; font-family: 'Fredoka One', cursive;
            font-size: 1.2em; cursor: pointer; box-shadow: 0 5px #3a6891; transition: background-color 0.1s;
        }

        /* GAME-SPECIFIC STYLES */
        #game-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; margin-top: 20px; }
        .game-icon { padding: 20px; background-color: #f0f0f0; border-radius: 10px; cursor: pointer; font-size: 1.1em; }
        .game-icon.coming-soon { opacity: 0.5; cursor: default; }

        #player-selector button { width: 60px; height: 60px; border-radius: 50%; padding: 0; margin: 5px; }
        #player-selector button.selected { background-color: #ff6347; box-shadow: 0 5px #cc4e37; }

        #mini-game-area { 
            display: grid; 
            gap: 5px; 
            height: 50vh; 
            width: 100%; 
            max-width: 400px; 
            margin: 20px auto; 
            /* Default grid setup is 4x3 for memory game, but JS adjusts this */
            grid-template-columns: repeat(4, 1fr);
            grid-template-rows: repeat(3, 1fr);
        }
        .player-area { 
            display: flex; justify-content: center; align-items: center; 
            border-radius: 15px; font-size: 2em; color: white; 
            transition: background-color 0.1s; 
            user-select: none;
            cursor: pointer;
        }
        /* CSS END */
    </style>
</head>
<body>

    <div id="ad-overlay">
        <button id="ad-close-btn" style="display:none;">&times;</button>
        <p id="ad-content-text">Loading Ad... ‚è≥</p>
        <p style="font-size: 0.5em; margin-top: 50px;">(Simulated AdMob Full-Screen Ad)</p>
    </div>

    <div id="game-container">
        
        <div id="menu-screen" class="screen active">
            <h1>Mini Battle üí•</h1>
            <p>1-4 Player Offline Fun</p>
            <button id="start-game-btn">Start Battle</button>
            <div id="game-grid">
                <div class="game-icon" data-game="tap">üëÜ Quick Tap</div>
                <div class="game-icon" data-game="memory">üß† Memory Match</div>
                <div class="game-icon coming-soon">ü§∏ Co-Ordination</div>
                <div class="game-icon coming-soon">‚è±Ô∏è Perfect Stop</div>
            </div>
        </div>

        <div id="setup-screen" class="screen">
            <h2>Players (1-4)</h2>
            <div id="player-selector">
                <button class="player-count-btn" data-count="1">1</button>
                <button class="player-count-btn selected" data-count="2">2</button>
                <button class="player-count-btn" data-count="3">3</button>
                <button class="player-count-btn" data-count="4">4</button>
            </div>
            <p id="player-status">Selected: 2 Players</p>
            <button id="start-battle-btn">Start Mini-Game Battle</button>
        </div>

        <div id="game-screen" class="screen">
            <h2 id="game-title"></h2>
            <p id="game-timer"></p>

            <div id="mini-game-area">
                <div class="player-area" data-player-id="1" style="background-color: #ff6347;">P1</div>
                <div class="player-area" data-player-id="2" style="background-color: #3cb371;">P2</div>
                <div class="player-area" data-player-id="3" style="background-color: #4682b4;">P3</div>
                <div class="player-area" data-player-id="4" style="background-color: #fca311;">P4</div>
            </div>
            <p id="game-instruction"></p>
        </div>

        <div id="score-screen" class="screen">
            <h2>üèÜ Scoreboard üèÜ</h2>
            <div id="score-list">Scores Go Here</div>
            <button id="next-round-btn">Next Mini-Game</button>
            <button id="back-to-menu-btn">Back to Menu</button>
        </div>
    </div>

    <div id="banner-ad-container">
        [AdMob Banner Ad Here: 320x50] üñºÔ∏è
    </div>

    <script>
        // JAVASCRIPT START üõ†Ô∏è

        // ====================================================================
        // !! PRODUCTION ID IMPLEMENTATION POINT !! üí° 
        // REPLACE THESE IDs with your LIVE IDs before packaging the APK.
        // ====================================================================
        const ADMOB_TEST_IDS = {
            APP_OPEN: 'ca-app-pub-3940256099942544/9257395921',
            BANNER: 'ca-app-pub-3940256099942544/6300978111',
            INTERSTITIAL: 'ca-app-pub-3940256099942544/1033173712'
        };

        // --- Game State Variables ---
        let currentRound = 0;
        let isAppOpenAdShown = false; 
        let playerCount = 2; 
        let scores = {'1': 0, '2': 0, '3': 0, '4': 0}; 
        let isGameActive = false;
        let currentGame = ''; // Tracks which mini-game is active ('tap' or 'memory')
        const MAX_ROUNDS = 5;
        const WIN_POINTS = 1;
        const PLAYER_COLORS = { '1': '#ff6347', '2': '#3cb371', '3': '#4682b4', '4': '#fca311' };
        
        // --- DOM Elements ---
        const menuScreen = document.getElementById('menu-screen');
        const setupScreen = document.getElementById('setup-screen');
        const gameScreen = document.getElementById('game-screen');
        const scoreScreen = document.getElementById('score-screen');
        const bannerAdContainer = document.getElementById('banner-ad-container');
        const adOverlay = document.getElementById('ad-overlay');
        const adContentText = document.getElementById('ad-content-text');
        const adCloseBtn = document.getElementById('ad-close-btn');
        const gameTitle = document.getElementById('game-title');
        const gameTimer = document.getElementById('game-timer');
        const gameInstruction = document.getElementById('game-instruction');
        const playerAreas = document.querySelectorAll('.player-area');
        const playerScoreList = document.getElementById('score-list');
        const playerCountButtons = document.querySelectorAll('.player-count-btn');
        const miniGameArea = document.getElementById('mini-game-area');
        
        const allScreens = { 'menu': menuScreen, 'setup': setupScreen, 'game': gameScreen, 'score': scoreScreen };


        // --- Player Setup Logic ---
        function updatePlayerSetup(count) {
            playerCount = count;
            document.getElementById('player-status').textContent = `Selected: ${count} Players`;
            playerCountButtons.forEach(btn => {
                btn.classList.remove('selected');
                if (parseInt(btn.dataset.count) === count) {
                    btn.classList.add('selected');
                }
            });

            // This function is mainly for Quick Tap/Split-Screen display
            playerAreas.forEach(area => {
                const id = area.dataset.playerId;
                area.style.display = (parseInt(id) <= count) ? 'flex' : 'none';
            });
        }

        // --- AdMob Simulation Functions (Kept the same) ---
        function showBannerAd(shouldShow) {
            const AD_ID = ADMOB_TEST_IDS.BANNER; 
            if (shouldShow) {
                bannerAdContainer.style.display = 'block';
                bannerAdContainer.textContent = `Banner Ad (TEST ID: ${AD_ID}) üñºÔ∏è`;
            } else {
                bannerAdContainer.style.display = 'none';
            }
        }
        function loadAndShowAppOpenAd(onAdClosed) {
            const AD_ID = ADMOB_TEST_IDS.APP_OPEN; 
            if (isAppOpenAdShown) { onAdClosed(); return; }
            adOverlay.classList.add('app-open');
            adOverlay.style.display = 'flex';
            adCloseBtn.style.display = 'none';
            setTimeout(() => {
                adContentText.textContent = `App Open Ad (TEST ID: ${AD_ID})`;
                adCloseBtn.style.display = 'block';
                adCloseBtn.onclick = () => { adOverlay.style.display = 'none'; isAppOpenAdShown = true; onAdClosed(); };
            }, 1500); 
        }
        function loadAndShowInterstitial(onAdClosed) {
            const AD_ID = ADMOB_TEST_IDS.INTERSTITIAL; 
            adOverlay.classList.add('interstitial');
            adOverlay.style.display = 'flex';
            adCloseBtn.style.display = 'none';
            setTimeout(() => {
                adContentText.textContent = `Interstitial Ad (TEST ID: ${AD_ID}) üé¨`;
                adCloseBtn.style.display = 'block';
                adCloseBtn.onclick = () => { adOverlay.style.display = 'none'; onAdClosed(); };
            }, 1000); 
        }

        // --- Screen Management ---
        function showScreen(screenName) {
            Object.values(allScreens).forEach(screen => screen.classList.remove('active'));
            allScreens[screenName].classList.add('active');

            // ADMOB BANNER TRIGGER
            const showAd = (screenName === 'menu' || screenName === 'score');
            showBannerAd(showAd);
        }
        
        // --- Scoring and Scoreboard ---
        function updateScoreboard() {
            let sortedScores = Object.keys(scores)
                .filter(id => parseInt(id) <= playerCount)
                .map(id => ({ playerId: id, score: scores[id] }))
                .sort((a, b) => b.score - a.score);

            playerScoreList.innerHTML = ''; 
            
            sortedScores.forEach((p, index) => {
                const scoreItem = document.createElement('p');
                scoreItem.style.color = PLAYER_COLORS[p.playerId];
                scoreItem.style.fontSize = (index === 0) ? '1.8em' : '1.3em';
                scoreItem.innerHTML = `P${p.playerId} - ${p.score} Wins ${index === 0 && p.score > 0 ? 'üèÜ' : ''}`;
                playerScoreList.appendChild(scoreItem);
            });

            if (currentRound >= MAX_ROUNDS) {
                document.getElementById('next-round-btn').style.display = 'none';
                document.getElementById('back-to-menu-btn').textContent = 'Finish Battle & Menu';
                gameTitle.textContent = 'FINAL RESULTS! ü•á';
            } else {
                document.getElementById('next-round-btn').style.display = 'inline-block';
                document.getElementById('back-to-menu-btn').textContent = 'Back to Menu';
                gameTitle.textContent = `End of Round ${currentRound}/${MAX_ROUNDS}`;
            }
        }

        // --- GAME LIBRARY ---
        const GAMES = [
            { id: 'tap', name: 'Quick Tap! üëÜ', initialize: initializeQuickTap },
            { id: 'memory', name: 'Memory Match üß†', initialize: initializeMemoryMatch }
        ];

        function selectNextGame() {
            // Randomly select one of the available games
            const availableGames = GAMES.filter(g => g.initialize);
            const randomIndex = Math.floor(Math.random() * availableGames.length);
            return availableGames[randomIndex];
        }

        // --- MINI-GAME LOGIC: QUICK TAP ---
        let quickTapTimerTimeout = null;

        function initializeQuickTap() {
            // Clear any old memory cards
            miniGameArea.innerHTML = ''; 
            
            // Re-append and configure player areas for Quick Tap visualization
            playerAreas.forEach(area => {
                miniGameArea.appendChild(area);
                const id = parseInt(area.dataset.playerId);
                area.style.display = (id <= playerCount) ? 'flex' : 'none';
                
                // Clear all memory listeners and add Quick Tap listener
                area.removeEventListener('click', handleMemoryClick);
                area.removeEventListener('click', handleTap); 
                area.addEventListener('click', handleTap); 
                
                area.style.backgroundColor = PLAYER_COLORS[id.toString()];
                area.textContent = `P${id}`;
                area.style.color = 'white'; 
                area.style.cursor = 'pointer';
                area.style.gridColumn = 'auto'; 
            });

            // Set grid structure for Quick Tap
            miniGameArea.style.gridTemplateColumns = '1fr 1fr';
            miniGameArea.style.gridTemplateRows = (playerCount > 2) ? '1fr 1fr' : '1fr';
            if (playerCount === 1) {
                document.querySelector('.player-area[data-player-id="1"]').style.gridColumn = '1 / span 2';
            }

            isGameActive = true;
            currentGame = 'tap';
            gameTitle.textContent = `Round ${currentRound}/${MAX_ROUNDS}: Quick Tap! üëÜ`;
            gameInstruction.textContent = 'Be the first to tap your area when the color changes!';

            clearTimeout(quickTapTimerTimeout);
            quickTapTimerTimeout = setTimeout(startQuickTapTimer, 1000);
        }
        
        function startQuickTapTimer() {
            const delay = Math.random() * (4000 - 1500) + 1500; 
            
            gameTimer.textContent = 'Wait for the signal... ‚è±Ô∏è';
            gameTimer.style.color = '#ff6347'; 

            quickTapTimerTimeout = setTimeout(() => {
                playerAreas.forEach(area => {
                    if(area.style.display !== 'none') {
                        area.style.backgroundColor = 'white';
                        area.textContent = '';
                    }
                });
                gameTimer.textContent = 'TAP NOW! üü¢';
                gameTimer.style.color = '#3cb371';
            }, delay);
        }

        function handleTap(event) {
            if (!isGameActive || currentGame !== 'tap') return;

            const winnerId = event.currentTarget.dataset.playerId;
            
            if (event.currentTarget.style.backgroundColor === 'white') {
                
                clearTimeout(quickTapTimerTimeout);
                isGameActive = false;
                scores[winnerId] += WIN_POINTS;

                gameInstruction.textContent = `P${winnerId} WINS ROUND ${currentRound}! üéâ`;
                gameInstruction.style.color = PLAYER_COLORS[winnerId];
                gameTimer.textContent = 'Tapped!';

                playerAreas.forEach(area => {
                    area.removeEventListener('click', handleTap);
                    if (area.dataset.playerId !== winnerId && area.style.display !== 'none') {
                        area.style.backgroundColor = '#ccc'; 
                    }
                });

                setTimeout(() => { showScreen('score'); }, 2000);

            } else if (event.currentTarget.style.backgroundColor !== 'black') {
                // False start logic 
                scores[winnerId] -= WIN_POINTS * 0.5; 
                event.currentTarget.textContent = 'TOO SOON! ‚ùå';
                event.currentTarget.style.backgroundColor = 'black';
            }
        }


        // --- MINI-GAME LOGIC: MEMORY MATCH ---
        let cards = [];
        let flippedCards = [];
        let matchedPairs = 0;
        let currentPlayer = '1';
        let playerMatches = {};
        let isMatchingPaused = false;

        function initializeMemoryMatch() {
            isGameActive = true;
            currentGame = 'memory';
            gameTitle.textContent = `Round ${currentRound}/${MAX_ROUNDS}: Memory Match üß†`;
            gameInstruction.textContent = `P${currentPlayer}'s turn. Find a pair!`;
            gameTimer.textContent = 'Matches: 0 / 6';
            
            // 1. Setup Game State
            playerMatches = {};
            for (let i = 1; i <= playerCount; i++) {
                playerMatches[i.toString()] = 0;
            }
            matchedPairs = 0;
            currentPlayer = '1';
            flippedCards = [];
            isMatchingPaused = false;

            // 2. Prepare Cards (6 pairs for a 4x3 grid)
            const totalPairs = 6;
            const emojiSet = ['üçé', 'üçå', 'üçá', 'üçì', 'ü•ù', 'üçã'];
            let cardValues = [...emojiSet.slice(0, totalPairs), ...emojiSet.slice(0, totalPairs)];
            
            // Shuffle function
            cardValues.sort(() => Math.random() - 0.5); 
            cards = cardValues.map((value, index) => ({
                id: index,
                value: value,
                isFlipped: false,
                isMatched: false
            }));

            // 3. Render Board (4 columns, 3 rows)
            miniGameArea.innerHTML = '';
            miniGameArea.style.display = 'grid';
            miniGameArea.style.gridTemplateColumns = 'repeat(4, 1fr)';
            miniGameArea.style.gridTemplateRows = 'repeat(3, 1fr)';
            
            cards.forEach((card, index) => {
                const cardElement = document.createElement('div');
                cardElement.className = 'player-area memory-card';
                cardElement.dataset.cardId = card.id;
                cardElement.style.backgroundColor = PLAYER_COLORS[currentPlayer]; 
                cardElement.textContent = '?';
                
                cardElement.removeEventListener('click', handleTap);
                cardElement.addEventListener('click', handleMemoryClick);
                miniGameArea.appendChild(cardElement);
            });
        }

        function handleMemoryClick(event) {
            if (!isGameActive || currentGame !== 'memory' || isMatchingPaused) return;

            const cardElement = event.currentTarget;
            const cardId = parseInt(cardElement.dataset.cardId);
            const card = cards.find(c => c.id === cardId);

            if (card.isFlipped || card.isMatched) return;

            // 1. Flip the card
            card.isFlipped = true;
            cardElement.textContent = card.value;
            cardElement.style.backgroundColor = 'white'; 
            cardElement.style.color = '#333';
            flippedCards.push(card);

            // 2. Check for Match
            if (flippedCards.length === 2) {
                isMatchingPaused = true;
                const [card1, card2] = flippedCards;

                if (card1.value === card2.value) {
                    // MATCH FOUND! ü•≥
                    card1.isMatched = true;
                    card2.isMatched = true;
                    matchedPairs++;
                    playerMatches[currentPlayer]++;

                    gameTimer.textContent = `Matches: ${matchedPairs} / 6 (P${currentPlayer}: +1)`;
                    gameInstruction.textContent = `MATCH! P${currentPlayer} gets another turn!`;

                    document.querySelectorAll(`[data-card-id="${card1.id}"], [data-card-id="${card2.id}"]`).forEach(el => {
                        el.style.backgroundColor = PLAYER_COLORS[currentPlayer];
                        el.style.color = 'white';
                        el.removeEventListener('click', handleMemoryClick);
                    });

                    if (matchedPairs === cards.length / 2) {
                        endMemoryMatch();
                        return;
                    }
                    
                    // Matched: Player gets another turn, but pause ends
                    setTimeout(() => {
                        flippedCards = [];
                        isMatchingPaused = false;
                        gameInstruction.textContent = `P${currentPlayer}'s turn. Find a pair!`;
                    }, 500);


                } else {
                    // NO MATCH! üòî
                    gameInstruction.textContent = 'No Match. Next player\'s turn!';

                    // Flip them back after a delay
                    setTimeout(() => {
                        card1.isFlipped = false;
                        card2.isFlipped = false;
                        document.querySelectorAll('.memory-card').forEach(el => {
                            const flipCard = cards.find(c => c.id === parseInt(el.dataset.cardId));
                            if (!flipCard.isMatched) {
                                // Set card back to next player's color
                                el.textContent = '?';
                                el.style.backgroundColor = PLAYER_COLORS[getNextPlayerId(currentPlayer)];
                                el.style.color = 'white';
                            }
                        });

                        // Switch player and reset
                        currentPlayer = getNextPlayerId(currentPlayer);
                        flippedCards = [];
                        isMatchingPaused = false;
                        gameInstruction.textContent = `P${currentPlayer}'s turn. Find a pair!`;
                    }, 1000);
                }
            }
        }

        function getNextPlayerId(currentId) {
            let nextId = parseInt(currentId) + 1;
            // Skip player IDs higher than the actual player count
            while (nextId > playerCount || nextId < 1) {
                if (nextId > playerCount) nextId = 1;
                else if (nextId < 1) nextId = 1;
            }
            return nextId.toString();
        }

        function endMemoryMatch() {
            isGameActive = false;
            
            // 1. Determine the winner (most matches)
            let winnerId = '1';
            let maxMatches = -1;
            let tiedPlayers = [];
            
            for (const [id, count] of Object.entries(playerMatches)) {
                if (parseInt(id) > playerCount) continue; // Only count active players

                if (count > maxMatches) {
                    maxMatches = count;
                    winnerId = id;
                    tiedPlayers = [id];
                } else if (count === maxMatches) {
                    tiedPlayers.push(id);
                }
            }

            // 2. Update Scores
            if (tiedPlayers.length === 1) {
                scores[winnerId] += WIN_POINTS;
                gameInstruction.textContent = `P${winnerId} WINS! (${maxMatches} Matches) üéâ`;
            } else {
                gameInstruction.textContent = 'It\'s a TIE! Next round... ü§ù';
            }
            
            // 3. Move to scoreboard
            setTimeout(() => { showScreen('score'); }, 2000);
        }


        // --- Game Flow ---
        function proceedToGameScreen() {
            showScreen('game');
            const nextGame = selectNextGame();
            nextGame.initialize(); // Initialize the selected game
        }

        function startNextMiniGame() {
            currentRound++; 
            if (currentRound > MAX_ROUNDS) {
                showScreen('score');
                return;
            }

            // ADMOB BREAKPOINT: INTERSTITIAL üé¨ (Trigger from round 2 onwards)
            if (currentRound > 1) { 
                loadAndShowInterstitial(() => { 
                    proceedToGameScreen(); 
                });
            } else {
                proceedToGameScreen();
            }
        }
        
        // --- Initialisation and Event Listeners ---
        
        // ADMOB BREAKPOINT: APP OPEN AD üö™
        window.onload = () => {
             loadAndShowAppOpenAd(() => { 
                updatePlayerSetup(2); 
                showScreen('menu');
             });
        }
        
        // Event listeners
        document.getElementById('start-game-btn').addEventListener('click', () => { showScreen('setup'); });
        document.getElementById('start-battle-btn').addEventListener('click', () => { 
            currentRound = 0; 
            Object.keys(scores).forEach(id => scores[id] = 0); // Reset scores
            startNextMiniGame(); 
        });
        document.getElementById('next-round-btn').addEventListener('click', startNextMiniGame);
        document.getElementById('back-to-menu-btn').addEventListener('click', () => { showScreen('menu'); });

        // Player count selector
        playerCountButtons.forEach(btn => {
            btn.addEventListener('click', () => {
                const count = parseInt(btn.dataset.count);
                updatePlayerSetup(count);
            });
        });

        // JAVASCRIPT END
    </script>
</body>
</html>
